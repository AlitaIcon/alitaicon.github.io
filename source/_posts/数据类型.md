---
title: 数据类型
date: 2019-06-26 08:47:32
tags: [python]
---

## **一，元组和列表**

**1.元组和列表的性能分析**

**ipython使用**

![img](/img/python/数据类型/ipython.png)

<!-- more -->

**pycharm中使用**

import timeit

![img](/img/python/数据类型/timeit.png)

性能分析：

时间：元组<列表<字典<集合

![img](/img/python/数据类型/analysis.png)

空间：元组<列表<集合<字典

![img](/img/python/数据类型/analysis2.png)



### **二、字典和集合原理和应用**

原理：

<https://blog.csdn.net/qq_29287973/article/details/78429209>

通过对字典的key值进行hash，取低位进行散列排序到表元，当发生散列冲突时（key值变动时），表元检测自动扩容，重新进行hash，所以字典排序不是固定的。

**命名元组**

![img](/img/python/数据类型/namedtuple.png)

**字典和集合**

![img](/img/python/数据类型/set_dict.png)



不可变元素可hash，可变元素不可hash，字典hash的值key值。



### 三、推导式**

**1.列表推导式**

需求：如何快速生成一个0-100的列表？

![img](/img/python/数据类型/list.png)

**列表推导式**

```python
list1 = [i for i in range(101)] list2 = ['page{}'.format(i) for i in range(101)] dict1 = {i : i+1 for i in range(101)} 
```



### 四、生成器和迭代器**

**1.生成器**

**关键字：yeild**

在函数中使用yeild关键字可以创建一个生成器

**2.迭代协议**

**2.1迭代协议**：一种包含iter()方法的，另一种保安getitem方法的（比如str对象就没有iter方法，但是一样能够迭代），只要对象中包含了这两种方法的任一种，那么这个对象就可以进行迭代操作，也就是实现了迭代协议。

**2.2迭代器协议**

实现了迭代器协议的对象（实现方式：对象内部定义了一个iter()方法）

对象实现了__next__方法

__next__方法返回了某个数值，取完数值后，抛出StopIteration

**2.3可迭代对象**：只要内部实现了迭代协议就是一个可迭代对象。

所有迭代器都是可迭代对象

**3.迭代器**

将一个可迭代对象转换成一个迭代器？

```python
list1 = [11,22,33]

li_ter = iter(li1)  #转换成迭代器



\#再过next取迭代器中的数据

print(next(li_iter()))

print(next(li_iter()))

....
```

问题：使用生成器的好处？

迭代器和生成器用在什么地方？有什么用？

当我们读取一个很大的数据的时候，比如说1万条或更多的数据量，此时数据放到列表不合适。

此时，使用生成器可以节省内存。生成器中保存的只是一个生成数据的相关算法，并不会把所有的数据都生成出来，在需要数据的时候，利用生成器生成一条数据接口，从而节省内存。

**4.生成器表达式**

```python
gen_ = (item for item in range(100))

print(gen_)        <generator object <genexpr> at 0x00000000026AB408>

print(next(gen_))

print(next(gen_))

.....

抛出StopIteration
```

**5.迭代器和生成器的区别：**

生成器属于迭代器的一种，如何区分迭代去和生成器？

1.生成器比迭代器多了三种方法：send(),close(),throw()

send()方法，发送数据

close()方法，关闭生成器

throw方法：

gen.throw(Exception,"Method throw called")



### **作业**

##### 1、使用字典推倒是将下面字符串格式的数据，改成字典类型的数据  

```python
cook_str = 'BIDUPSID=D0727533D7147B7;PSTM=1530348042; BAIDUID=B1005C9BC2EB28; sugstore=0;__cfduid=d0a13458f8ac2a;BD_UPN=12314353;ispeed_lsm=2;BDORZ=B490B5EBF6F3CD402' 
```

**答：**

```python
res = {s.split('=')[0]: s.split('=')[1] for s in cook_str.split(';')} print(res)  
```



##### 2、当前有文件case.xlsx，设计程序将case.xlsx中的用例读取到一个生成器？    

```python
import openpyxl

import logging



class DoExcel:


    def __init__(self, filename, sheetname):

        self.filename = filename

        self.sheetname = sheetname


    def read_data(self):

        """

        读取文件中的所有测试数据


        :return:

        """

        try:

            wb = openpyxl.load_workbook(self.filename)

            sh = wb[self.sheetname]

            logging.info("开始读取{}中的{}数据".format(self.filename, self.sheetname))

            col_max = sh.max_column

            testdata_key = []

            for i in range(1, col_max + 1):

                testdata_key.append(sh.cell(1, i).value)

            row_max = sh.max_row

            row_start = 2

            for i in range(row_start, row_max + 1):

                testdata = {}

                for j in range(1, col_max + 1):

                    testdata[testdata_key[j - 1]] = sh.cell(i, j).value

                yield testdata

        except Exception as e:

            logging.warning("出错啦，错误信息是：{}".format(e))
    2.第二种    
    wb = openpyxl.load_workbook(self.filename)
    sh = wb[self.sheetname]
    logger.info("开始读取{}中的{}数据".format(self.filename, self.sheetname))
    col_max = sh.max_column
    row_max = sh.max_row
    row_start = 2
    for row in range(row_start,row_max+1):
        testdata = {}
        for col in range(1,col_max+1):
            testdata[sh.cell(row=1,column=col).value] =sh.cell(row=row,column=col).value
        yield testdata
  
    3.第三种
    wb = openpyxl.load_workbook(self.filename)
    sh = wb[self.sheetname]
    logger.info("开始读取{}中的{}数据".format(self.filename, self.sheetname))
    col_max = sh.max_column+1
    row_max = sh.max_row+1
    testdatas = ({sh.cell(1,j).value: sh.cell(i,j).value for j in range(1,col_max)} for i in range(2,row_max))
    return testdatas


if __name__ == '__main__':

    import os


    dir_path = os.path.abspath(os.path.dirname(__file__))

    path = dir_path + "/cases.xlsx"

    exc = DoExcel(path, "cases")

    er = exc.read_data()

    print(next(er))

    print(next(er))

    print(next(er))

    print(next(er))

    print(next(er))
```

##### 3、请描述什么是可迭代对象？ 什么是迭代器？ 迭代器和生成器的区别？

```python
可以使用for循环遍历的对象是可迭代对象，如list、str、tuple、dict、set；
任何实现了__iter__和__next__()方法的对象都是迭代器，通过iter(str)可以把可迭代对象str生成一个迭代器；
str1 = 'qweqweqwedd'
si = iter(str1)
print(next(si))
print(next(si))
print(next(si))
print(next(si))
迭代器：
迭代器有两个基本的方法：iter() 和 next()。任何实现了__iter__和__next__()方法的对象都是迭代器。__iter__返回迭代器自身，__next__返回容器中的下一个值。
迭代器是一个可以记住遍历的位置的对象。
迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
生成器：
生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。
生成器比迭代器多了三种方法：send(),close(),throw()
第一种生成器：
gen =(x+2 for x in range(10))
print(gen)
第二种生成器：
def gen():
for i in range(1,100):
yeild i
n = gen()
调用
print(next(n))
print(next(n))
.....
直至取出所有值后，抛出异常StopIteration，已经没有迭代项了
```

[**Python itertools模块详解**](https://www.cnblogs.com/fengshuihuan/p/7105545.html)

<https://www.cnblogs.com/fengshuihuan/p/7105545.html>